{"version":3,"file":"boid.js","sources":["../src/vec2.js","../src/boid.js"],"sourcesContent":["const {acos, atan2, cos, sin, sqrt} = Math;\n\nconst pool = [];\n\nexport default class Vec2 {\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n\n    add(vec) {\n        this.x = this.x + vec.x;\n        this.y = this.y + vec.y;\n        return this;\n    }\n\n    subtract(vec) {\n        this.x = this.x - vec.x;\n        this.y = this.y - vec.y;\n        return this;\n    }\n\n    normalize() {\n        const lsq = this.lengthSquared;\n        if (lsq === 0) {\n            this.x = 1;\n            return this;\n        }\n        if (lsq === 1) {\n            return this;\n        }\n        const l = sqrt(lsq);\n        this.x /= l;\n        this.y /= l;\n        return this;\n    }\n\n    isNormalized() {\n        return this.lengthSquared === 1;\n    }\n\n    truncate(max) {\n        // if (this.length > max) {\n        if (this.lengthSquared > max * max) {\n            this.length = max;\n        }\n        return this;\n    }\n\n    scaleBy(mul) {\n        this.x *= mul;\n        this.y *= mul;\n        return this;\n    }\n\n    divideBy(div) {\n        this.x /= div;\n        this.y /= div;\n        return this;\n    }\n\n    equals(vec) {\n        return this.x === vec.x && this.y === vec.y;\n    }\n\n    negate() {\n        this.x = -this.x;\n        this.y = -this.y;\n        return this;\n    }\n\n    dotProduct(vec) {\n        /*\n        If A and B are perpendicular (at 90 degrees to each other), the result\n        of the dot product will be zero, because cos(Θ) will be zero.\n        If the angle between A and B are less than 90 degrees, the dot product\n        will be positive (greater than zero), as cos(Θ) will be positive, and\n        the vector lengths are always positive values.\n        If the angle between A and B are greater than 90 degrees, the dot\n        product will be negative (less than zero), as cos(Θ) will be negative,\n        and the vector lengths are always positive values\n        */\n        return this.x * vec.x + this.y * vec.y;\n    }\n\n    crossProduct(vec) {\n        /*\n        The sign tells us if vec to the left (-) or the right (+) of this vec\n        */\n        return this.x * vec.y - this.y * vec.x;\n    }\n\n    distanceSq(vec) {\n        const dx = vec.x - this.x;\n        const dy = vec.y - this.y;\n        return dx * dx + dy * dy;\n    }\n\n    distance(vec) {\n        return sqrt(this.distanceSq(vec));\n    }\n\n    clone() {\n        return Vec2.get(this.x, this.y);\n    }\n\n    reset() {\n        this.x = 0;\n        this.y = 0;\n        return this;\n    }\n\n    perpendicular() {\n        return Vec2.get(-this.y, this.x);\n    }\n\n    sign(vec) {\n        // Determines if a given vector is to the right or left of this vector.\n        // If to the left, returns -1. If to the right, +1.\n        const p = this.perpendicular();\n        const s = p.dotProduct(vec) < 0 ? -1 : 1;\n        p.dispose();\n        return s;\n    }\n\n    set(angle, length) {\n        this.x = cos(angle) * length;\n        this.y = sin(angle) * length;\n        return this;\n    }\n\n    dispose() {\n        this.x = 0;\n        this.y = 0;\n        pool.push(this);\n    }\n\n    get lengthSquared() {\n        return this.x * this.x + this.y * this.y;\n    }\n\n    get length() {\n        return sqrt(this.lengthSquared);\n    }\n\n    set length(value) {\n        const a = this.angle;\n        this.x = cos(a) * value;\n        this.y = sin(a) * value;\n    }\n\n    get angle() {\n        return atan2(this.y, this.x);\n    }\n\n    set angle(value) {\n        const l = this.length;\n        this.x = cos(value) * l;\n        this.y = sin(value) * l;\n    }\n\n    static get(x, y) {\n        const v = pool.length > 0 ? pool.pop() : new Vec2();\n        v.x = x || 0;\n        v.y = y || 0;\n        return v;\n    }\n\n    static fill(n) {\n        while (pool.length < n) {\n            pool.push(new Vec2());\n        }\n    }\n\n    static angleBetween(a, b) {\n        if (!a.isNormalized()) {\n            a = a.clone().normalize();\n        }\n        if (!b.isNormalized()) {\n            b = b.clone().normalize();\n        }\n        return acos(a.dotProduct(b));\n    }\n}\n","import Vec2 from './vec2.js';\n\nconst PI_D2 = Math.PI / 2;\n\nconst defaults = {\n    bounds: {\n        x: 0,\n        y: 0,\n        width: 640,\n        height: 480\n    },\n    edgeBehavior: 'bounce',\n    mass: 1.0,\n    maxSpeed: 10,\n    maxForce: 1,\n    arriveThreshold: 50,\n    wanderDistance: 10,\n    wanderRadius: 5,\n    wanderAngle: 0,\n    wanderRange: 1,\n    avoidDistance: 300,\n    avoidBuffer: 20,\n    pathThreshold: 20,\n    maxDistance: 300,\n    minDistance: 60\n};\n\nfunction setDefaults(opts, defs) {\n    Object.keys(defs).forEach((key) => {\n        if (typeof opts[key] === 'undefined') {\n            opts[key] = defs[key];\n        }\n    });\n}\n\nfunction configure(options) {\n    options = options || {};\n    options.bounds = options.bounds || {};\n    setDefaults(options, defaults);\n    setDefaults(options.bounds, defaults.bounds);\n    return options;\n}\n\nexport default function Boid(options) {\n    options = configure(options);\n\n    let boid = null;\n    const position = Vec2.get();\n    const velocity = Vec2.get();\n    const steeringForce = Vec2.get();\n\n    const bounds = options.bounds;\n    let edgeBehavior = options.edgeBehavior;\n    let mass = options.mass;\n    let maxSpeed = options.maxSpeed;\n    let maxSpeedSq = maxSpeed * maxSpeed;\n    let maxForce = options.maxForce;\n    // arrive\n    let arriveThreshold = options.arriveThreshold;\n    let arriveThresholdSq = arriveThreshold * arriveThreshold;\n    // wander\n    let wanderDistance = options.wanderDistance;\n    let wanderRadius = options.wanderRadius;\n    let wanderAngle = options.wanderAngle;\n    let wanderRange = options.wanderRange;\n    // avoid\n    let avoidDistance = options.avoidDistance;\n    let avoidBuffer = options.avoidBuffer;\n    // follow path\n    let pathIndex = 0;\n    let pathThreshold = options.pathThreshold;\n    let pathThresholdSq = pathThreshold * pathThreshold;\n    // flock\n    let maxDistance = options.maxDistance;\n    let maxDistanceSq = maxDistance * maxDistance;\n    let minDistance = options.minDistance;\n    let minDistanceSq = minDistance * minDistance;\n\n    function setBounds(width, height, x, y) {\n        bounds.width = width;\n        bounds.height = height;\n        bounds.x = x || 0;\n        bounds.y = y || 0;\n\n        return boid;\n    }\n\n    function bounce() {\n        const maxX = bounds.x + bounds.width;\n        if (position.x > maxX) {\n            position.x = maxX;\n            velocity.x *= -1;\n        } else if (position.x < bounds.x) {\n            position.x = bounds.x;\n            velocity.x *= -1;\n        }\n\n        const maxY = bounds.y + bounds.height;\n        if (position.y > maxY) {\n            position.y = maxY;\n            velocity.y *= -1;\n        } else if (position.y < bounds.y) {\n            position.y = bounds.y;\n            velocity.y *= -1;\n        }\n    }\n\n    function wrap() {\n        const maxX = bounds.x + bounds.width;\n        if (position.x > maxX) {\n            position.x = bounds.x;\n        } else if (position.x < bounds.x) {\n            position.x = maxX;\n        }\n\n        const maxY = bounds.y + bounds.height;\n        if (position.y > maxY) {\n            position.y = bounds.y;\n        } else if (position.y < bounds.y) {\n            position.y = maxY;\n        }\n    }\n\n    function seek(targetVec) {\n        const desiredVelocity = targetVec.clone().subtract(position);\n        desiredVelocity.normalize();\n        desiredVelocity.scaleBy(maxSpeed);\n\n        const force = desiredVelocity.subtract(velocity);\n        steeringForce.add(force);\n        force.dispose();\n\n        return boid;\n    }\n\n    function flee(targetVec) {\n        const desiredVelocity = targetVec.clone().subtract(position);\n        desiredVelocity.normalize();\n        desiredVelocity.scaleBy(maxSpeed);\n\n        const force = desiredVelocity.subtract(velocity);\n        steeringForce.subtract(force);\n        force.dispose();\n\n        return boid;\n    }\n\n    // seek until within arriveThreshold\n    function arrive(targetVec) {\n        const desiredVelocity = targetVec.clone().subtract(position);\n        desiredVelocity.normalize();\n\n        const distanceSq = position.distanceSq(targetVec);\n        if (distanceSq > arriveThresholdSq) {\n            desiredVelocity.scaleBy(maxSpeed);\n        } else {\n            const scalar = maxSpeed * distanceSq / arriveThresholdSq;\n            desiredVelocity.scaleBy(scalar);\n        }\n        const force = desiredVelocity.subtract(velocity);\n        steeringForce.add(force);\n        force.dispose();\n\n        return boid;\n    }\n\n    // look at velocity of boid and try to predict where it's going\n    function pursue(targetBoid) {\n        const lookAheadTime = position.distanceSq(targetBoid.position) / maxSpeedSq;\n\n        const scaledVelocity = targetBoid.velocity.clone().scaleBy(lookAheadTime);\n        const predictedTarget = targetBoid.position.clone().add(scaledVelocity);\n\n        seek(predictedTarget);\n\n        scaledVelocity.dispose();\n        predictedTarget.dispose();\n\n        return boid;\n    }\n\n    // look at velocity of boid and try to predict where it's going\n    function evade(targetBoid) {\n        const lookAheadTime = position.distanceSq(targetBoid.position) / maxSpeedSq;\n\n        const scaledVelocity = targetBoid.velocity.clone().scaleBy(lookAheadTime);\n        const predictedTarget = targetBoid.position.clone().add(scaledVelocity);\n\n        flee(predictedTarget);\n\n        scaledVelocity.dispose();\n        predictedTarget.dispose();\n\n        return boid;\n    }\n\n    // wander around, changing angle by a limited amount each tick\n    function wander() {\n        const center = velocity.clone().normalize().scaleBy(wanderDistance);\n\n        const offset = Vec2.get();\n        offset.set(wanderAngle, wanderRadius);\n        // offset.length = wanderRadius;\n        // offset.angle = wanderAngle;\n        wanderAngle += Math.random() * wanderRange - wanderRange * 0.5;\n\n        const force = center.add(offset);\n        steeringForce.add(force);\n\n        offset.dispose();\n        force.dispose();\n\n        return boid;\n    }\n\n    // gets a bit rough used in combination with seeking as the boid attempts\n    // to seek straight through an object while simultaneously trying to avoid it\n    function avoid(obstacles) {\n        for (let i = 0; i < obstacles.length; i++) {\n            const obstacle = obstacles[i];\n            const heading = velocity.clone().normalize();\n\n            // vec between obstacle and boid\n            const difference = obstacle.position.clone().subtract(position);\n            const dotProd = difference.dotProduct(heading);\n\n            // if obstacle in front of boid\n            if (dotProd > 0) {\n                // vec to represent 'feeler' arm\n                const feeler = heading.clone().scaleBy(avoidDistance);\n                // project difference onto feeler\n                const projection = heading.clone().scaleBy(dotProd);\n                // distance from obstacle to feeler\n                const vecDistance = projection.subtract(difference);\n                const distance = vecDistance.length;\n                // if feeler intersects obstacle (plus buffer), and projection\n                // less than feeler length, will collide\n                if (distance < (obstacle.radius || 0) + avoidBuffer && projection.length < feeler.length) {\n                    // calc a force +/- 90 deg from vec to circ\n                    const force = heading.clone().scaleBy(maxSpeed);\n                    force.angle += difference.sign(velocity) * PI_D2;\n                    // scale force by distance (further = smaller force)\n                    const dist = projection.length / feeler.length;\n                    force.scaleBy(1 - dist);\n                    // add to steering force\n                    steeringForce.add(force);\n                    // braking force - slows boid down so it has time to turn (closer = harder)\n                    velocity.scaleBy(dist);\n\n                    force.dispose();\n                }\n                feeler.dispose();\n                projection.dispose();\n                vecDistance.dispose();\n            }\n            heading.dispose();\n            difference.dispose();\n        }\n        return boid;\n    }\n\n    // follow a path made up of an array or vectors\n    function followPath(path, loop) {\n        loop = !!loop;\n\n        const wayPoint = path[pathIndex];\n        if (!wayPoint) {\n            pathIndex = 0;\n            return boid;\n        }\n        if (position.distanceSq(wayPoint) < pathThresholdSq) {\n            if (pathIndex >= path.length - 1) {\n                if (loop) {\n                    pathIndex = 0;\n                }\n            } else {\n                pathIndex++;\n            }\n        }\n        if (pathIndex >= path.length - 1 && !loop) {\n            arrive(wayPoint);\n        } else {\n            seek(wayPoint);\n        }\n        return boid;\n    }\n\n    // is boid close enough to be in sight and facing\n    function inSight(b) {\n        if (position.distanceSq(b.position) > maxDistanceSq) {\n            return false;\n        }\n        const heading = velocity.clone().normalize();\n        const difference = b.position.clone().subtract(position);\n        const dotProd = difference.dotProduct(heading);\n\n        heading.dispose();\n        difference.dispose();\n\n        return dotProd >= 0;\n    }\n\n    // flock - group of boids loosely move together\n    function flock(boids) {\n        const averageVelocity = velocity.clone();\n        const averagePosition = Vec2.get();\n        let inSightCount = 0;\n        for (let i = 0; i < boids.length; i++) {\n            const b = boids[i];\n            if (b !== boid && inSight(b)) {\n                averageVelocity.add(b.velocity);\n                averagePosition.add(b.position);\n\n                if (position.distanceSq(b.position) < minDistanceSq) {\n                    flee(b.position);\n                }\n                inSightCount++;\n            }\n        }\n        if (inSightCount > 0) {\n            averageVelocity.divideBy(inSightCount);\n            averagePosition.divideBy(inSightCount);\n            seek(averagePosition);\n            steeringForce.add(averageVelocity.subtract(velocity));\n        }\n        averageVelocity.dispose();\n        averagePosition.dispose();\n\n        return boid;\n    }\n\n    function update() {\n        steeringForce.truncate(maxForce);\n        if (mass !== 1) {\n            steeringForce.divideBy(mass);\n        }\n        // velocity.add(steeringForce);\n        velocity.x += steeringForce.x;\n        velocity.y += steeringForce.y;\n        // steeringForce.reset();\n        steeringForce.x = 0;\n        steeringForce.y = 0;\n        velocity.truncate(maxSpeed);\n        // position.add(velocity);\n        position.x += velocity.x;\n        position.y += velocity.y;\n\n        if (edgeBehavior === Boid.EDGE_BOUNCE) {\n            bounce();\n        } else if (edgeBehavior === Boid.EDGE_WRAP) {\n            wrap();\n        }\n        return boid;\n    }\n\n    boid = {\n        bounds,\n        setBounds,\n        update,\n        pursue,\n        evade,\n        wander,\n        avoid,\n        followPath,\n        flock,\n        arrive,\n        seek,\n        flee,\n        position,\n        velocity,\n        userData: {}\n    };\n\n    // getters / setters\n    Object.defineProperties(boid, {\n        edgeBehavior: {\n            get: function() {\n                return edgeBehavior;\n            },\n            set: function(value) {\n                edgeBehavior = value;\n            }\n        },\n        mass: {\n            get: function() {\n                return mass;\n            },\n            set: function(value) {\n                mass = value;\n            }\n        },\n        maxSpeed: {\n            get: function() {\n                return maxSpeed;\n            },\n            set: function(value) {\n                maxSpeed = value;\n                maxSpeedSq = value * value;\n            }\n        },\n        maxForce: {\n            get: function() {\n                return maxForce;\n            },\n            set: function(value) {\n                maxForce = value;\n            }\n        },\n        // arrive\n        arriveThreshold: {\n            get: function() {\n                return arriveThreshold;\n            },\n            set: function(value) {\n                arriveThreshold = value;\n                arriveThresholdSq = value * value;\n            }\n        },\n        // wander\n        wanderDistance: {\n            get: function() {\n                return wanderDistance;\n            },\n            set: function(value) {\n                wanderDistance = value;\n            }\n        },\n        wanderRadius: {\n            get: function() {\n                return wanderRadius;\n            },\n            set: function(value) {\n                wanderRadius = value;\n            }\n        },\n        wanderRange: {\n            get: function() {\n                return wanderRange;\n            },\n            set: function(value) {\n                wanderRange = value;\n            }\n        },\n        // avoid\n        avoidDistance: {\n            get: function() {\n                return avoidDistance;\n            },\n            set: function(value) {\n                avoidDistance = value;\n            }\n        },\n        avoidBuffer: {\n            get: function() {\n                return avoidBuffer;\n            },\n            set: function(value) {\n                avoidBuffer = value;\n            }\n        },\n        // followPath\n        pathIndex: {\n            get: function() {\n                return pathIndex;\n            },\n            set: function(value) {\n                pathIndex = value;\n            }\n        },\n        pathThreshold: {\n            get: function() {\n                return pathThreshold;\n            },\n            set: function(value) {\n                pathThreshold = value;\n                pathThresholdSq = value * value;\n            }\n        },\n        //  flock\n        maxDistance: {\n            get: function() {\n                return maxDistance;\n            },\n            set: function(value) {\n                maxDistance = value;\n                maxDistanceSq = value * value;\n            }\n        },\n        minDistance: {\n            get: function() {\n                return minDistance;\n            },\n            set: function(value) {\n                minDistance = value;\n                minDistanceSq = value * value;\n            }\n        }\n    });\n\n    return Object.freeze(boid);\n}\n\n// edge behaviors\nBoid.EDGE_NONE = 'none';\nBoid.EDGE_BOUNCE = 'bounce';\nBoid.EDGE_WRAP = 'wrap';\n\n// vec2\nBoid.Vec2 = Vec2;\n\nBoid.vec2 = function(x, y) {\n    return Vec2.get(x, y);\n};\n\n// for defining obstacles or areas to avoid\nBoid.obstacle = function(radius, x, y) {\n    return {\n        radius: radius,\n        position: Vec2.get(x, y)\n    };\n};\n"],"names":["acos","Math","atan2","cos","sin","sqrt","pool","Vec2","x","y","add","vec","subtract","normalize","lsq","lengthSquared","l","isNormalized","truncate","max","length","scaleBy","mul","divideBy","div","equals","negate","dotProduct","crossProduct","distanceSq","dx","dy","distance","clone","get","reset","perpendicular","sign","p","s","dispose","set","angle","push","v","pop","fill","n","angleBetween","a","b","value","PI_D2","PI","defaults","setDefaults","opts","defs","keys","forEach","key","configure","options","bounds","Boid","boid","position","velocity","steeringForce","edgeBehavior","mass","maxSpeed","maxSpeedSq","maxForce","arriveThreshold","arriveThresholdSq","wanderDistance","wanderRadius","wanderAngle","wanderRange","avoidDistance","avoidBuffer","pathIndex","pathThreshold","pathThresholdSq","maxDistance","maxDistanceSq","minDistance","minDistanceSq","setBounds","width","height","bounce","maxX","maxY","wrap","seek","targetVec","desiredVelocity","force","flee","arrive","scalar","pursue","targetBoid","lookAheadTime","scaledVelocity","predictedTarget","evade","wander","center","offset","random","avoid","obstacles","i","obstacle","heading","difference","dotProd","feeler","projection","vecDistance","radius","dist","followPath","path","loop","wayPoint","inSight","flock","boids","averageVelocity","averagePosition","inSightCount","update","EDGE_BOUNCE","EDGE_WRAP","defineProperties","Object","freeze","EDGE_NONE","vec2"],"mappings":"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"}